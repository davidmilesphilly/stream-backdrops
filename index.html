<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1/selfie_segmentation.js"></script>
<script>
/***********************************************************************
 *  CDN-only, single SelfieSegmentation instance
 ***********************************************************************/
const GITHUB_USER = 'davidmilesphilly';
const GITHUB_REPO = 'stream-backdrops';
const FOLDER      = 'backgrounds';

const bgSelect    = document.getElementById('bgSelect');
const webcam      = document.getElementById('webcam');
const canvas      = document.getElementById('canvas');
const ctx         = canvas.getContext('2d');
const cameraStatus= document.getElementById('cameraStatus');
const snapBtn     = document.getElementById('snapBtn');
const galleryGrid = document.getElementById('gallery-grid');
const fullscreen  = document.getElementById('fullscreen-preview');
const previewImg  = document.getElementById('preview-image');
const closeBtn    = document.querySelector('.close-preview');

let bgImg       = new Image();
let selfie, currentStream;

/* Background discovery via GitHub API */
async function fetchBackgrounds() {
  const apiURL = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${FOLDER}`;
  const r = await fetch(apiURL);
  if (!r.ok) return [];
  const list = await r.json();
  return list.filter(f => /(jpg|jpeg|png|webp)$/i.test(f.name))
             .map(f => `https://cdn.jsdelivr.net/gh/${GITHUB_USER}/${GITHUB_REPO}@main/${FOLDER}/${f.name}`);
}

/* DOM population */
function initUI(urls) {
  bgSelect.innerHTML = '<option value="" disabled selected>Select background...</option>';
  urls.forEach(url => {
    const opt = document.createElement('option');
    opt.value = url;
    opt.textContent = url.split('/').pop().replace(/\.(jpg|jpeg|png|webp)$/i, '').replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    bgSelect.appendChild(opt);
  });
  galleryGrid.innerHTML = '';
  urls.forEach(url => {
    const card = document.createElement('div');
    card.className = 'card';
    const img = new Image();
    img.src = url;
    img.alt = url.split('/').pop();
    img.loading = 'lazy';
    const dl = document.createElement('button');
    dl.className = 'download-btn';
    dl.textContent = 'Download';
    dl.onclick = e => { e.stopPropagation(); const a = document.createElement('a'); a.href = url; a.download = ''; a.click(); };
    card.onclick = () => { previewImg.src = url; fullscreen.style.display = 'flex'; };
    card.append(img, dl);
    galleryGrid.appendChild(card);
  });
}

/* Camera */
async function initCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
    currentStream = stream;
    webcam.srcObject = stream;
    cameraStatus.textContent = 'Camera active';
    cameraStatus.className = 'camera-status active';
    snapBtn.disabled = false;
    webcam.onloadedmetadata = () => {
      canvas.width  = webcam.videoWidth;
      canvas.height = webcam.videoHeight;
      startSegmentation();
    };
  } catch (e) {
    cameraStatus.textContent = 'Camera error: ' + e.message;
    cameraStatus.className = 'camera-status error';
  }
}

/* Segmentation */
function startSegmentation() {
  selfie = new SelfieSegmentation({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1/${file}`
  });
  selfie.setOptions({ modelSelection: 1 });
  selfie.onResults(results => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (bgImg.src && bgImg.complete) {
      ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.globalCompositeOperation = 'source-in';
    ctx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(webcam, 0, 0, canvas.width, canvas.height);
  });
  function loop() {
    if (webcam.readyState >= webcam.HAVE_ENOUGH_DATA) selfie.send({ image: webcam });
    requestAnimationFrame(loop);
  }
  loop();
}

/* Events */
document.addEventListener('DOMContentLoaded', async () => {
  initUI(await fetchBackgrounds());
  initCamera();
});
bgSelect.addEventListener('change', e => {
  if (e.target.value) { bgImg = new Image(); bgImg.crossOrigin = 'anonymous'; bgImg.src = e.target.value; }
});
document.getElementById('snapBtn').addEventListener('click', () => {
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = 'backdrop.png';
  a.click();
});
document.getElementById('fullscreen-preview').addEventListener('click', e => {
  if (e.target === fullscreen || e.target === closeBtn) fullscreen.style.display = 'none';
});
</script>
